/*
  knockback-transitions.js 0.1.1
  (c) 2011, 2012 Kevin Malakoff - http://kmalakoff.github.com/knockback/
  License: MIT (http://www.opensource.org/licenses/mit-license.php)
  Dependencies: Knockout.js, Backbone.js, and Underscore.js.
*/
(function() {
  return (function(factory) {
    // AMD
    if (typeof define === 'function' && define.amd) {
      return define('knockback-transitions', factory);
    }
    // CommonJS/NodeJS or No Loader
    else {
      return factory.call(this);
    }
  })(function() {// Generated by CoffeeScript 1.3.3
var FALLBACK_ANIMATION_DURATION, extractStyles, kb, wrapAnimCallback, _anim_fn;

try {
  this.kb = kb = !this.kb && (typeof require !== 'undefined') ? require('knockback') : this.kb;
} catch (e) {
  ({});
}

this.kb || (this.kb = kb || (kb = {}));

kb.transitions || (kb.transitions = {});

kb.fallback_transitions || (kb.fallback_transitions = {});

kb.transitions.END_EVENT = (function() {
  var END_EVENT_NAMES, el, event, style;
  el = document.createElement('knockback');
  END_EVENT_NAMES = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd otransitionend',
    'msTransition': 'MSTransitionEnd',
    'transition': 'transitionend'
  };
  for (style in END_EVENT_NAMES) {
    event = END_EVENT_NAMES[style];
    if (el.style[style] !== void 0) {
      return event;
    }
  }
  return 'kbTransitionEnd';
})();

kb.active_transitions = (kb.transitions.END_EVENT === 'kbTransitionEnd' ? kb.fallback_transitions : kb.transitions);

$.fn.startTransition = function(classes, callback) {
  var cleanupCallback,
    _this = this;
  if (typeof classes === 'function') {
    callback = classes;
    classes = null;
  }
  cleanupCallback = function() {
    _this.off(kb.transitions.END_EVENT, cleanupCallback);
    return !callback || callback();
  };
  this.removeClass(classes);
  this.one(kb.transitions.END_EVENT, cleanupCallback);
  this.addClass(classes);
  setTimeout(cleanupCallback, 300);
};

$.fn.stopTransition = function() {
  this.trigger(kb.transitions.END_EVENT);
};

extractStyles = function(el) {
  var name, style, styles, _ref;
  styles = {};
  _ref = el.style;
  for (name in _ref) {
    style = _ref[name];
    if (!style) {
      continue;
    }
    styles[name] = style;
  }
  return styles;
};

kb.TransitionSavedState = (function() {

  function TransitionSavedState(info) {
    var el, name;
    this.el_states = [];
    for (name in info) {
      el = info[name];
      !_.isElement(el) || this.el_states.push({
        el: el,
        className: el.className,
        cssText: el.style.cssText
      });
    }
    return;
  }

  TransitionSavedState.prototype.restore = function() {
    var el, state, _i, _len, _ref;
    _ref = this.el_states;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      state = _ref[_i];
      el = state.el;
      el.className = state.className;
      el.style.cssText = state.cssText;
    }
    this.el_states = null;
  };

  return TransitionSavedState;

})();

if (typeof exports !== 'undefined') {
  exports.TransitionSavedState = kb.TransitionSavedState;
}

kb.transitions.SlideUp = function(info, options) {
  if (!info.from) {
    info.callback();
    return;
  }
  $(info.to).css({
    'height': $(info.container).height()
  }).startTransition((options.forward ? 'on-top slideup in' : 'on-top slideup out reverse'), info.callback);
};

kb.transitions.FadeIn = function(info, options) {
  var $to;
  $to = $(info.to).css({
    'min-height': $(info.container).height()
  });
  $to.startTransition((options.forward ? 'on-top fade in' : 'on-top fade out'), info.callback);
};

kb.transitions.Slide = function(info, options) {
  var $from, $to, width;
  if (!info.from) {
    info.callback();
    return;
  }
  width = $(info.container).width();
  $from = $(info.from).css({
    'width': width
  });
  $to = $(info.to).css({
    'width': width
  });
  if (options.forward) {
    $from.startTransition('slide out');
    $to.startTransition('slide in', info.callback);
  } else {
    $to.startTransition('slide out reverse');
    $from.startTransition('slide in reverse', info.callback);
  }
};

FALLBACK_ANIMATION_DURATION = kb.FALLBACK_ANIMATION_DURATION = 300;

if (this.Zepto) {
  wrapAnimCallback = function(el, properties, callback) {
    el.__kb_zepto_endEvent = typeof properties === 'string' ? $.fx.animationEnd : $.fx.transitionEnd;
    el.__kb_zepto_callback = function() {
      if (!el.__kb_zepto_endEvent) {
        return;
      }
      delete el.__kb_zepto_endEvent;
      delete el.__kb_zepto_callback;
      return !callback || callback.call(this);
    };
    return el.__kb_zepto_callback;
  };
  _anim_fn = $.fn.anim;
  $.fn.anim = function(properties, duration, ease, callback) {
    var el, replacement_callback, _i, _len;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      el = this[_i];
      replacement_callback = wrapAnimCallback(el, properties, callback);
    }
    _anim_fn.call(this, properties, duration, ease, replacement_callback);
    return this;
  };
  $.fn.stop = function() {
    var el, _i, _len;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      el = this[_i];
      if (el.__kb_zepto_endEvent) {
        $(el).trigger(el.__kb_zepto_endEvent);
      }
    }
    return this;
  };
}

kb.fallback_transitions.SlideUp = function(info, options) {
  var $to, callback, duration, height, top;
  if (!info.from) {
    info.callback();
    return;
  }
  $to = $(info.to);
  callback = function() {
    $to.stop();
    return info.callback();
  };
  duration = 'duration' in options ? options.duration : FALLBACK_ANIMATION_DURATION;
  height = info.container.clientHeight;
  top = info.to.clientTop;
  if (options.forward) {
    $to.addClass('on-top').css({
      top: top + height
    }).animate({
      top: top
    }, duration, 'linear', callback);
  } else {
    $to.addClass('on-top').animate({
      top: top + height
    }, duration, 'linear', callback);
  }
  $to.startTransition(callback);
};

kb.fallback_transitions.FadeIn = function(info, options) {
  var $to, duration;
  $to = $(info.to).css({
    'min-height': $(info.container).height()
  });
  duration = 'duration' in options ? options.duration : FALLBACK_ANIMATION_DURATION;
  if (options.forward) {
    $to.css({
      'opacity': 0
    });
    $to.animate({
      'opacity': 1
    }, 1000, 'swing', info.callback);
  } else {
    $to.css({
      'opacity': 1
    });
    $to.animate({
      'opacity': 0
    }, 1000, 'swing', info.callback);
  }
  $to.startTransition(info.callback);
};

kb.fallback_transitions.Slide = function(info, options) {
  var $from, $to, callback, duration, from_left, to_left, width;
  if (!info.from) {
    info.callback();
    return;
  }
  $to = $(info.to);
  $from = $(info.from);
  callback = function() {
    $from.stop();
    $to.stop();
    return info.callback();
  };
  duration = 'duration' in options ? options.duration : FALLBACK_ANIMATION_DURATION;
  width = $(info.container).width();
  if (options.forward) {
    $from.animate({
      left: info.from.clientLeft - width
    }, duration, 'linear');
    to_left = info.to.clientLeft;
    $to.css({
      left: to_left + width
    }).animate({
      left: to_left
    }, duration, 'linear', callback);
  } else {
    from_left = info.from.clientLeft;
    $from.css({
      left: from_left - width
    }).animate({
      left: from_left
    }, duration, 'linear');
    $to.animate({
      left: info.to.clientLeft + width
    }, duration, 'linear', callback);
  }
  return $to.startTransition(callback);
};

return;
; return kb;});
}).call(this);